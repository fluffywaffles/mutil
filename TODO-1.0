- `update*` improvements/consistency fixes:
  - `update[_value]`: updates `value` (preserves descriptor)
  - `update_descriptor`: updates `descriptor`
  - `update_entry`: apply(update_value)
  - `update_entries`: over(apply(update_value))
  - `update_property`: apply(update_descriptor)
  - `update_properties`: over(apply(update_descriptor))
  - `update_with`: { [key]: value => value, ... } (preserves descriptors)
  - `update_values`: update_with
  - `update_descriptors`: { [key]: descriptor => descriptor, ... }
  - `update_path[_value]`: [ key, ... ] => (value => value)
  - `update_path_descriptor`: [ key, ... ] => (descriptor => descriptor)
- Now the taxonomy is:
  - `set*`: set/create new
  - `update*`: modify existing
    - `_path*`: at the end of a path
      - `_entry`: [ key, value ]
      - `_value`: key => value
      - `_values`: { [key]: value, ... } merge
      - `_property`: [ key, descriptor ]
      - `_descriptor`: key => descriptor
      - `_descriptors`: { [key]: descriptor, ... } merge
- Make sure all functions are tested
  - Including modules (d, linchpin, ...)
- Make sure mutative alternates are tested
- `reflex.type` helpers
  - reflex.type.undefined, reflex.type.number, reflex.type.string, etc.
  - reduces the 'reflex.type(types.undefined)` style boilerplate
- Add more mutative alternates (where applicable)
- `fallible.or`: supersedes `update_or` below with a more general solution
  - `update_or`: update_or(handle_none)(key)(updater)(target)
    - e.g.: update_or(set_value(value)) for supplying a default
- Timers?
  - wait  ↔ setTimeout
  - every ↔ setInterval
  - soon  ↔ {setIdleCallback,requestAnimationFrame}

"Deep" update:

update_path([ 'x', 'y', 'z' ])(v => v + 1)({ x: { y: { z: 5 } } })
=> { x: { y: { z: 6 } } }

"update*_or" ?

update_or = key => fallback => updater => object => {
  ᐅif(has(key)(object))
}

update_or_set = key => ({ initial }) => updater => object => {
  return update
    (key)
    (ᐅif(reflex.type(types.undefined))(_ => initial)(updater))
    (object)
}

const count_up = update_or_set('count')({ intitial: 0 })(v => v + 1)
const counter = {}
times(5)(count_up)(counter) // { count: 4 }
