- Make `update*` functions work for properties, entries, descriptors...
  - `update_value`, `update_descriptor`
  - does `update_value` respect the descriptor? (no)
  - `update` does the mid-optimal thing: it wraps `update_descriptor`
    but takes a function on `value`; so, if you just use the "obvious"
    thing, it behaves in an obvious way. If you use `update_value` for
    some reason, you're opting in to the "ignore descriptor
    configuration" outcome. You can also use `update_descriptor` to get
    access to get/set and other descriptor configuration.
- Fix `update_with`
- Add `set*` functions for setting (but not overwriting) values
- Now the taxonomy is:
  - `set*`: create a new {entry,property}
  - `define*`: set/change an {entry,property}
  - `update*`: modify an existing {entry,property}
- Try to remove some `define*` functions -- seems like too many
- Make sure all functions are tested
- Make sure mutative alternates are tested
- `reflex.type` helpers
  - reflex.type.undefined, reflex.type.number, reflex.type.string, etc.
  - reduces the 'reflex.type(types.undefined)` style boilerplate
- `fallible.or`: supersedes `update_or` below with a more general solution
  - `update_or`: update_or(handle_none)(key)(updater)(target)
    - e.g.: update_or(set_value(value)) for supplying a default

update_or_set = key => ({ initial }) => updater => object => {
  return update
    (key)
    (ᐅif(reflex.type(types.undefined))(_ => initial)(updater))
    (object)
}

const count_up = update_or_set('count')({ intitial: 0 })(v => v + 1)
const counter = {}
times(5)(count_up)(counter) // { count: 4 }
